generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                    String                 @id @default(uuid())
  email                 String                 @unique
  password              String
  name                  String
  currency              String                 @default("USD")
  timezone              String                 @default("America/Mexico_City")
  avatar                String?
  createdAt             DateTime               @default(now())
  resetToken            String?
  resetTokenExpiry      DateTime?
  accounts              Account[]
  budgets               Budget[]
  categories            Category[]
  installmentPurchases  InstallmentPurchase[]
  loans                 Loan[]
  recurringTransactions RecurringTransaction[]
  transactions          Transaction[]
}

model Account {
  id                      String                 @id @default(uuid())
  name                    String
  type                    String
  balance                 Float
  creditLimit             Float?
  cutoffDay               Int?
  paymentDay              Int?
  userId                  String
  user                    User                   @relation(fields: [userId], references: [id])
  installmentPurchases    InstallmentPurchase[]
  loans                   Loan[]
  recurringTransactions   RecurringTransaction[]
  transactions            Transaction[]
  destinationTransactions Transaction[]          @relation("DestinationTransactions")
}

model Transaction {
  id                     String                @id @default(uuid())
  amount                 Float
  description            String
  date                   DateTime
  type                   String
  userId                 String
  categoryId             String?
  accountId              String?
  createdAt              DateTime              @default(now())
  updatedAt              DateTime              @updatedAt
  recurringTransactionId String?
  installmentPurchaseId  String?
  loanId                 String?
  destinationAccountId   String?               @map("destination_account_id")
  deletedAt              DateTime?
  account                Account?              @relation(fields: [accountId], references: [id])
  category               Category?             @relation("CategoryTransactions", fields: [categoryId], references: [id])
  destinationAccount     Account?              @relation("DestinationTransactions", fields: [destinationAccountId], references: [id])
  installmentPurchase    InstallmentPurchase?  @relation("InstallmentTransactions", fields: [installmentPurchaseId], references: [id])
  loan                   Loan?                 @relation(fields: [loanId], references: [id])
  recurringTransaction   RecurringTransaction? @relation("RecurringTransactions", fields: [recurringTransactionId], references: [id])
  user                   User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model InstallmentPurchase {
  id                    String        @id @default(uuid())
  description           String
  totalAmount           Float
  installments          Int
  monthlyPayment        Float
  purchaseDate          DateTime
  paidInstallments      Int           @default(0)
  paidAmount            Float         @default(0)
  accountId             String
  userId                String
  categoryId            String
  account               Account       @relation(fields: [accountId], references: [id])
  category              Category      @relation(fields: [categoryId], references: [id])
  user                  User          @relation(fields: [userId], references: [id])
  generatedTransactions Transaction[] @relation("InstallmentTransactions")
}

model Category {
  id                    String                 @id @default(uuid())
  name                  String
  icon                  String
  color                 String
  type                  String
  budgetType            String?
  userId                String
  user                  User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  installmentPurchases  InstallmentPurchase[]
  recurringTransactions RecurringTransaction[]
  transactions          Transaction[]          @relation("CategoryTransactions")

  @@unique([name, userId])
}

model Budget {
  id        String   @id @default(uuid())
  name      String
  amount    Float
  startDate DateTime
  endDate   DateTime
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RecurringTransaction {
  id           String        @id @default(uuid())
  amount       Float
  description  String
  type         String
  frequency    String
  startDate    DateTime
  nextDueDate  DateTime
  active       Boolean       @default(true)
  lastRun      DateTime?
  userId       String
  categoryId   String
  accountId    String
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  account      Account       @relation(fields: [accountId], references: [id])
  category     Category      @relation(fields: [categoryId], references: [id])
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions Transaction[] @relation("RecurringTransactions")
}

model Loan {
  id              String    @id @default(uuid())
  borrowerName    String    // Nombre de la persona (quien te debe o a quien debes)
  borrowerPhone   String?   // Teléfono de contacto (opcional)
  borrowerEmail   String?   // Email de contacto (opcional)
  reason          String?   // Motivo del préstamo
  loanType        String    @default("lent") // "lent" = presté (me deben), "borrowed" = me prestaron (debo)
  originalAmount  Float     // Cantidad original prestada
  remainingAmount Float     // Lo que aún falta por pagar
  loanDate        DateTime  // Fecha del préstamo
  expectedPayDate DateTime? // Fecha esperada de pago (null = sin fecha límite)
  status          String    @default("active") // active, partial, paid
  notes           String?   // Notas adicionales
  
  userId          String
  accountId       String?   // Cuenta afectada (opcional)
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  account         Account?  @relation(fields: [accountId], references: [id])
  transactions    Transaction[] // Relación con transacciones
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}
